{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"工厂模式","slug":"工厂模式","date":"2022-08-19T01:28:34.823Z","updated":"2022-08-19T01:29:22.962Z","comments":true,"path":"2022/08/19/工厂模式/","link":"","permalink":"http://example.com/2022/08/19/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"1、工厂方法模式（Factory Method） 工厂方法模式分为以下三种： （1）、普通工厂模式 就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子） 首先，创建二者的共同接口： 123public interface Sender &#123; public void Send(); &#125;","text":"1、工厂方法模式（Factory Method） 工厂方法模式分为以下三种： （1）、普通工厂模式 就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子） 首先，创建二者的共同接口： 123public interface Sender &#123; public void Send(); &#125; 其次，创建实现类： 12345678910111213public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(&quot;this is mailsender!&quot;); &#125; &#125;public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(&quot;this is sms sender!&quot;); &#125; &#125; 最后，建工厂类： 12345678910111213public class SendFactory &#123; public Sender produce(String type) &#123; if (&quot;mail&quot;.equals(type)) &#123; return new MailSender(); &#125; else if (&quot;sms&quot;.equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println(&quot;请输入正确的类型!&quot;); return null; &#125; &#125; &#125; 我们来测试下： 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce(&quot;sms&quot;); sender.Send(); &#125; &#125; 输出：this is sms sender! (2)多个工厂方法模式 该模式是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图： 将上面的代码做下修改，改动下SendFactory类就行，如下： 123456789public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类如下： 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); &#125; &#125; 输出：this is mailsender! （3）静态工厂方法模式 将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 1234567891011121314151617public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125; &#125; public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125; &#125; 输出：this is mailsender! 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 2、抽象工厂模式（Abstract Factory） 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。 请看例子： 123public interface Sender &#123; public void Send(); &#125; 两个实现类： 12345678910111213public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(&quot;this is mailsender!&quot;); &#125; &#125;public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(&quot;this is sms sender!&quot;); &#125; &#125; 两个工厂类： 1234567891011121314public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125; &#125; public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125; &#125; 在提供一个接口： 123public interface Provider &#123; public Sender produce(); &#125; 测试类： 12345678public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125; &#125; 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！","categories":[],"tags":[]},{"title":"反射","slug":"反射","date":"2022-08-19T00:57:25.832Z","updated":"2022-08-19T01:25:59.760Z","comments":true,"path":"2022/08/19/反射/","link":"","permalink":"http://example.com/2022/08/19/%E5%8F%8D%E5%B0%84/","excerpt":"1. Junit单元测试（重在应用）1.1 概述: JUnit是一个Java语言的单元测试 单元：一个方法就是一个单元 测试: 测方法中的代码逻辑是否正确 1.2 作用 替代main方法 10 10 求和 求积数 求商数 ​ 一个类只能有一个main方法 如果有N个功能要单独测试的话， ​ 需要写N个类由N个main方法进行不同的测试 单元测试让功能的测试更加的简单 1.3 实现方式 JUnit的使用步骤 1.导JUnit单元测试的jar包 (idea开发工具已经集成了junit的jar包) 2.在类中要测试的方法上添加 @Test 3.测试执行 JUnit的细节整理 1.方法必须得是公共的 2.返回值必须得是void 3.方法不能有任何的参数 示例:123456789101112131415public class JunitDemo &#123; /** * 单元测试的细节点 * 1.修饰符必须是公共的 * 2.方法的返回值必须是void * 3.方法必须是无参 * 4.注解必须加在方法上 */ @Test public void test() &#123; System.out.println(&quot;这个方法用于聊细节&quot;); &#125;&#125;","text":"1. Junit单元测试（重在应用）1.1 概述: JUnit是一个Java语言的单元测试 单元：一个方法就是一个单元 测试: 测方法中的代码逻辑是否正确 1.2 作用 替代main方法 10 10 求和 求积数 求商数 ​ 一个类只能有一个main方法 如果有N个功能要单独测试的话， ​ 需要写N个类由N个main方法进行不同的测试 单元测试让功能的测试更加的简单 1.3 实现方式 JUnit的使用步骤 1.导JUnit单元测试的jar包 (idea开发工具已经集成了junit的jar包) 2.在类中要测试的方法上添加 @Test 3.测试执行 JUnit的细节整理 1.方法必须得是公共的 2.返回值必须得是void 3.方法不能有任何的参数 示例:123456789101112131415public class JunitDemo &#123; /** * 单元测试的细节点 * 1.修饰符必须是公共的 * 2.方法的返回值必须是void * 3.方法必须是无参 * 4.注解必须加在方法上 */ @Test public void test() &#123; System.out.println(&quot;这个方法用于聊细节&quot;); &#125;&#125; 常见注解 @Before：在每个测试方法之前都会运行一次 @After：在每个测试方法运行以后运行的方法 @Test: 方法测试 示例:123456789101112131415161718192021222324252627282930public class JunitDemo &#123; /** * 单元测试的细节点 * 1.修饰符必须是公共的 * 2.方法的返回值必须是void * 3.方法必须是无参 */ @Test public void test() &#123; System.out.println(&quot;这个方法用于聊细节&quot;); &#125; /** * before在@Test执行之前执行 */ @Before public void before() &#123; System.out.println(&quot;在@Test执行之前执行...&quot;); &#125; /** * after@Test执行之后执行 */ @After public void after() &#123; System.out.println(&quot;@Test执行之后执行...&quot;); &#125;&#125; 2. 反射2.1 概述: 反射是一种机制，利用该机制可以在程序运行过程中对类进行解剖并操作类中的方法，属性，构造方法成员 123456789101112131415161718类: 构造方法 成员方法 成员变量一个类的执行流程：hello.java ---编译--&gt; hello.class ---加载内存--&gt; 运行Student.java ---编译--&gt; Student.class ---加载内存--&gt; 运行Person.java ---编译--&gt; Person.class ---加载内存--&gt; 运行接收类型：int类型用来接收数值，String类型用来接收字符串同理 hello.class Student.class Person.class也可以被指定类型接收Class（字节码对象）: 接收一切类的字节码Constructor（构造器对象）: 接收类中的一切构造方法Method（方法对象）: 接收类中的一切成员方法Field（变量对象）: 接收类中的一切成员变量 2.2 作用： 通过反射可以获取到每个类的字节码对象，拿到其中的构造方法，成员方法和成员变量 ps应用场景: 后期我们要学的ssm框架底层用到了很多的反射机制，为了后面能够更加理解框架，这里需要同学们对反射机制熟练化 2.3 核心：2.3.1 反射获取字节码对象的三种方式（重要） 方式1：通过类名.class获取 示例:1234567891011public class GetClassDemo &#123; /** * 方式1：通过类名.class获取 */ @Test public void test01() &#123; Class clazz = Student.class; System.out.println(&quot;clazz = &quot; + clazz); &#125;&#125; 方式2：通过Object类的成员方法getClass()方法获取 示例:123456789101112public class GetClassDemo &#123; /** * 方式2：通过Object类的成员方法getClass()方法获取 */ @Test public void test02() &#123; Class clazz = new Student().getClass(); System.out.println(&quot;clazz = &quot; + clazz); &#125;&#125; 方式3：通过Class.forName(“全限定名”)方法获取 示例:123456789101112public class GetClassDemo &#123; /** * 通过Class.forName(&quot;全限定名&quot;)方法获取 */ @Test public void test03() throws ClassNotFoundException &#123; Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); System.out.println(&quot;clazz = &quot; + clazz); &#125;&#125; ps全限定名: 就是包名 + 类名 2.3.2 相关API(Class, Constructor,Method,Field)1. Class对象相关方法 String getName(); 获取全限定名，包含 包名+类名 示例:123456789101112public class ClassAPTDemo &#123; @Test public void test01() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; //获取字节码文件 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取全限定类名 String name = clazz.getName(); System.out.println(&quot;name = &quot; + name);&#125; String getSimpleName(); 获得简单类名，只是类名，没有包名 示例:12345678910111213public class ClassAPTDemo &#123; @Test public void test01() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; //获取字节码文件 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取简单类名 String name = clazz.getSimpleName(); System.out.println(&quot;name = &quot; + name); &#125;&#125; T newInstance() ;创建此 Class 对象所表示的类的一个新实例。要求：类必须有public的无参数构造方法 示例:1234567891011121314public class ClassAPTDemo &#123; @Test public void test01() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; //获取字节码文件 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //直接创建对象--&gt;类必须有public的无参数构造方法 Student student = (Student) clazz.newInstance(); System.out.println(&quot;student = &quot; + student); &#125;&#125; 2. 操作构造方法(Constructor)–3遍以上 Constructor getConstructor(Class… parameterTypes)根据参数类型获取构造方法对象，只能获得public修饰的构造方法。 示例:123456789101112131415161718public class ConstructorDemo &#123; @Test public void test01() throws ClassNotFoundException, NoSuchMethodException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //根据字节码对象获取构造器对象(Constructor) //1.获取公共的无参构造器--&gt;通过无参构造器创建对象 Constructor constructor1 = clazz.getConstructor(); System.out.println(&quot;constructor1 = &quot; + constructor1); //2.获取公共的有参构造器--&gt;通过有参构造器创建对象 //有参:添加参数类型(字节码类型 .class类型) Constructor constructor2 = clazz.getConstructor(String.class, int.class); System.out.println(&quot;constructor2 = &quot; + constructor2); &#125;&#125; Constructor getDeclaredConstructor(Class… parameterTypes)根据参数类型获取构造方法对象，包括private修饰的构造方法。 示例:1234567891011121314public class ConstructorDemo &#123; @Test public void test01() throws ClassNotFoundException, NoSuchMethodException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取私有的有参构造器--&gt;通过有参构造器对象 //可以获取公共和私有的构造器,建议只用来获取私有 Constructor constructor3 = clazz.getDeclaredConstructor(String.class); System.out.println(&quot;constructor3 = &quot; + constructor3); &#125;&#125; T newInstance(Object… initargs)根据构造器中的指定参数创建对象。 示例:1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ConstructorDemo &#123; /** * 获取公共的无参构造器--通过无参构造器创建对象 */ @Test public void test01() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Constructor constructor = clazz.getConstructor(); Student student = (Student) constructor.newInstance(); System.out.println(&quot;student = &quot; + student); &#125; /** * 获取公共的有参构造器--通过有参构造器创建对象 */ @Test public void test02() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Constructor constructor = clazz.getConstructor(String.class, int.class); Student student = (Student) constructor.newInstance(&quot;张三&quot;, 18); System.out.println(&quot;student = &quot; + student); &#125; /** * 获取私有的有参构造器--通过有参构造器创建对象 */ @Test public void test03() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Constructor constructor = clazz.getDeclaredConstructor(String.class); //暴力破解私有 constructor.setAccessible(true); Student student = (Student) constructor.newInstance(&quot;张三&quot;); System.out.println(&quot;student = &quot; + student); &#125;&#125; void setAccessible(true)暴力反射，设置为可以直接访问私有类型的构造方法 Constructor[] getConstructors() (了解)获取所有的public修饰的构造方法 示例:1234567891011121314151617public class ConstructorDemo &#123; /** * 获取所有的公共构造器 */ @Test public void test01() throws ClassNotFoundException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(&quot;constructor = &quot; + constructor); &#125; &#125;&#125; Constructor[] getDeclaredConstructors() (了解)获取所有构造方法，包括privat修饰的 示例:1234567891011121314151617public class ConstructorDemo &#123; /** * 获取所有的公共构造器和私有构造器 */ @Test public void test01() throws ClassNotFoundException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(&quot;constructor = &quot; + constructor); &#125; &#125;&#125; 3. 操作方法(Method)–3遍以上Method是方法类，类中的每一个方法都是Method的对象，通过Method对象可以调用方法。 Method getMethod(“方法名”, 方法的参数类型… 类型)根据方法名和参数类型获得一个方法对象，只能是获取public修饰的 示例:123456789101112131415public class MethodDemo &#123; @Test public void test01() throws ClassNotFoundException, NoSuchMethodException &#123; //1.获取字节码对象 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //2.获取公共的方法 Method method1 = clazz.getMethod(&quot;getName&quot;); System.out.println(&quot;method1 = &quot; + method1); Method method2 = clazz.getMethod(&quot;setName&quot;, String.class); System.out.println(&quot;method2 = &quot; + method2); &#125;&#125; Method getDeclaredMethod(“方法名”, 方法的参数类型… 类型)根据方法名和参数类型获得一个方法对象，包括private修饰的 示例:1234567891011121314public class MethodDemo &#123; @Test public void test01() throws ClassNotFoundException, NoSuchMethodException &#123; //1.获取字节码对象 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //2.获取私有的方法 Method method = clazz.getDeclaredMethod(&quot;getName&quot;); System.out.println(&quot;method = &quot; + method); &#125;&#125; Object invoke(Object obj, Object… args) 核心方法使用反射的方式让一个方法执行 obj : 要执行该方法的对象 args : 方法运行过程中需要的参数 示例:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MethodDemo &#123; /** * 获取公共的无参的run方法--&gt;然run方法执行 */ @Test public void test01() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Student student = (Student) clazz.newInstance(); //获取公共的无参的run方法--&gt;然run方法执行 Method method1 = clazz.getMethod(&quot;run&quot;); /** * 方法执行 * 参数1:执行该方法的对象 * 参数2:方法运行中需要的参数,没有就不写 */ String value = (String) method1.invoke(student); System.out.println(&quot;value = &quot; + value); &#125; /** * 获取公共的有参的run方法--&gt;然run方法执行 */ @Test public void test02() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Student student = (Student) clazz.newInstance(); //获取公共的有参的run方法--&gt;然run方法执行 Method method = clazz.getMethod(&quot;run&quot;, String.class); /** * 方法执行 * 参数1:执行该方法的对象 * 参数2:方法运行中需要的参数,没有就不写 */ method.invoke(student, &quot;aaaaaa&quot;); &#125; /** * 获取私有的有参的run方法--&gt;然run方法执行 */ @Test public void test03() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Student student = (Student) clazz.newInstance(); //获取公共的有参的run方法--&gt;然run方法执行 Method method = clazz.getDeclaredMethod(&quot;stop&quot;, String.class); /** * 方法执行 * 参数1:执行该方法的对象 * 参数2:方法运行中需要的参数,没有就不写 */ //暴力破解 method.setAccessible(true); method.invoke(student, &quot;aaaaaa&quot;); &#125;&#125; void setAccessible(boolean flag)暴力反射，设置为true可以直接调用私有修饰的成员方法 Method[] getMethods() (了解)获取所有的public修饰的成员方法，包括父类中。 示例:1234567891011121314151617public class MethodDemo &#123; /** * 获取所有公共的(包含父类的) */ @Test public void test01() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; System.out.println(&quot;method = &quot; + method); &#125; &#125;&#125; Method[] getDeclaredMethods() (了解)获取当前类中所有的方法，包含私有的，不包括父类中。 示例:12345678910111213141516171819public class MethodDemo &#123; /** * 获取所有私有的(不包含父类的) */ @Test public void test01() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; //获取字节码 Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取所有的公共和私有方法(不包含父类) Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method method : declaredMethods) &#123; System.out.println(&quot;method = &quot; + method); &#125; &#125;&#125; 4. 操作属性(Field)成员变量–了解Field是属性类，类中的每一个属性(成员变量)都是Field的对象，通过Field对象可以给对应的成员变量赋值和取值。 Field getField(String name)根据属性名获得属性对象，只能获取public修饰的 示例:12345678910111213141516public class FieldDemo &#123; /** * 获取公共字段 */ @Test public void test01() throws ClassNotFoundException, NoSuchFieldException &#123; Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取公共的字段 //参数:字段名 Field field = clazz.getField(&quot;name&quot;); System.out.println(&quot;field = &quot; + field); &#125; &#125;&#125; Field getDeclaredField(String name)根据属性名获得属性对象，包括private修饰的 示例:1234567891011121314151617public class FieldDemo &#123; /** * 获取私有字段 */ @Test public void test01() throws ClassNotFoundException, NoSuchFieldException &#123; Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取私有字段 //参数:字段名 //获取私有字段 Field field = clazz.getDeclaredField(&quot;age&quot;); System.out.println(&quot;field = &quot; + field); &#125; &#125;&#125; Field[] getFields()获取所有的public修饰的属性对象，返回数组。 示例:12345678910111213141516public class FieldDemo &#123; /** * 获取所有公共字段 */ @Test public void test01() throws ClassNotFoundException, NoSuchFieldException &#123; Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取所有的公共字段 Field[] fields = clazz.getFields(); for (Field field : fields) &#123; System.out.println(&quot;field = &quot; + field); &#125; &#125;&#125; Field[] getDeclaredFields()获取所有的属性对象，包括private修饰的，返回数组 示例:12345678910111213141516public class FieldDemo &#123; /** * 获取所有字段 */ @Test public void test01() throws ClassNotFoundException, NoSuchFieldException &#123; Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取所有字段(私有和公共) Field[] declaredFields = clazz.getDeclaredFields(); for (Field field : declaredFields) &#123; System.out.println(&quot;field = &quot; + field); &#125; &#125;&#125; getType() (了解)反射获取字段类型的全限定名 示例:12345678910111213141516171819202122public class FieldDemo &#123; /** * 反射获取字段类型的全限定名 */ @Test public void test01() throws ClassNotFoundException, NoSuchFieldException &#123; Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); //获取所有字段(私有和公共) Field[] declaredFields = clazz.getDeclaredFields(); for (Field field : declaredFields) &#123; System.out.println(&quot;field = &quot; + field); /** * 获取当期属性的类型的全类名 * java.lang.string */ System.out.println(&quot;field = &quot; + field.getType()); &#125; &#125;&#125; set(字段所属的对象，要赋的值) 给字段赋值的，如果是私有的还是要先暴力破解 示例:12345678910111213141516171819202122232425public class FieldDemo &#123; /** * 给属性赋值 */ @Test public void test01() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class clazz = Class.forName(&quot;cn.kgc.entity.Student&quot;); Student student = (Student) clazz.newInstance(); Field field1 = clazz.getField(&quot;name&quot;); /** * 赋值 * 参数1:本身这个字段所属的对象 * 参数2:要赋的值 */ field1.set(student, &quot;迪丽热巴&quot;); System.out.println(&quot;student = &quot; + student); //私有属性 Field field2 = clazz.getDeclaredField(&quot;age&quot;); field2.setAccessible(true); field2.set(student, 19); System.out.println(&quot;student = &quot; + student); &#125;&#125; 小结:12345678910111213141516171819junit: 单元测试 作用: 代替main方法 使用: 1.导入junit的jar包 2.编写单元测试类(公共,无参,无返回值) @Test 3.在测试类中编写测试逻辑 API: @Before @After反射: 作用: 解剖字节码文件 Class: 类的字节码 Constructor: 构造器的字节码 Method: 方法的字节码 Field: 属性的字节码作业: 使用反射技术,解析properties配置文件中的信息,将读取的信息封装到Student实体中. 案例1:1需求:使用反射技术,解析properties配置文件中的信息,将读取的信息封装到Student实体中. 示例:properties配置文件123class=cn.kgc.entity.Studentname=abcdage=18 示例:java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ReflectionDemo &#123; /** * 根据配置文件进行解析,将解析的name和age...反射的方式赋值 * 步骤: * 1.解析src下面的student.properties配置文件 * 2.获取配置文件中的class的key得到value,根据value获取到全限定名 * 3.根据指定key反射出student中的字段(Filed) * 4.根据执行key的value给获取到的字段赋值 * @throws IOException */ @Test public void test1() throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123; //1.解析src下面的student.properties配置文件 Properties properties = new Properties(); //获取类加载器:可以加载src下面的配置文件直接转成流 //类加载器:将.class字节码文件加载到内存 获取 //FileInputStream inputStream = new FileInputStream(&quot;src/student.properties&quot;); InputStream inputStream = ReflectionDemo.class.getClassLoader().getResourceAsStream(&quot;student.properties&quot;); properties.load(inputStream); //2.获取配置文件中的class的key得到value,根据value获取到全限定名 Class clazz = Class.forName(properties.getProperty(&quot;class&quot;)); Student student = (Student) clazz.newInstance(); //根据指定的key反射出student中的字段(filed) Set&lt;String&gt; keys = properties.stringPropertyNames(); for (String key : keys) &#123; //判断只要age和name if (&quot;class&quot;.equals(key) == false) &#123; //根据key获取到字段对象 Field field = clazz.getDeclaredField(key); field.setAccessible(true); //赋值 String value = properties.getProperty(key); //判断类型 if (field.getType() == int.class) &#123; //4.根据指定的key的value给获取到的字段赋值 field.set(student, Integer.parseInt(value)); &#125;else &#123; field.set(student, value); &#125; &#125; &#125; System.out.println(&quot;student = &quot; + student); &#125;&#125; 3 注解3.1 概述: 在java中由一个 @+一堆英文单词组成的集合就是注解 它可以声明在类、字段、方法、局部变量、方法参数上等，用来对程序进行说明的 12345678注释：给程序员看的注解：给程序去看的 声明不同注解可以让程序做不同的功能注解的学习明确： 1 明确java或者框架提供的注解都有什么功能 2 明确提供的注解能定义在哪个位置上 （类上 字段上 方法上 局部变量上 参数上） 3.2 jdk中的注解 @Override声明该方法是重写的方法 @Deprecated声明该方法不推荐使用 3.3 扩展：自定义注解 格式: public @interface 注解名称{ ​ 类型 属性名(); ​ ……… }注解本质上就是一个特殊的接口 注解中的方法叫做属性. 示例:12345public @interface MyAn1 &#123; String value();&#125; 属性: 基本类型 (byte,short,int,long,float,double,boolean,char) String Class Annotation 以上类型的一维数组 示例:123456789public @interface MyAn1 &#123; String value(); int i(); Class clazz(); MyAn2 MY_AN_2(); String[] arr(); &#125; 常见的注解类 myAnnotation 示例:123public @interface MyAn2 &#123; String value() default &quot;123&quot;;&#125; myAnnotation(“abc”) 示例:123public @interface MyAn3 &#123; String value();&#125; myAnnotation(value &#x3D; “asd”, i &#x3D; 123,arr &#x3D; {“aa”, “bb”, “cc”}) 示例:1234567public @interface MyAn4 &#123; String value(); int i(); String[] arr();&#125; 注意事项: 注解一旦有了属性,使用注解时,必须给属性赋值 注解属性名称如果为value且只有一个,那么属性名称可以省去不写 123456自定义注解小结: 1.自定义注解格式: public @interface 注解名称&#123;&#125; 2.注解可以使用在类,方法,接口,成员变量,局部变量.... 3.注解中的方法不叫方法,叫属性 4.当注解中有属性时,使用该注解时,必须给注解中的属性赋值 5.注解属性名称如果为value且只有一个,那么属性名称可以省去不写 3.4 元注解定义在注解之上的注解被称为元注解 @Target 定义该注解作用在什么上面 值为: METHOD:方法 TYPE:类 接口 FIELD:字段 示例:12345@Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.FIELD&#125;)public @interface MyAn5 &#123; String name(); int age();&#125; @Retention 定义该注解保留到那个代码阶段 值为: SOURCE:注解只在源码上保留 (默认) CLASS:注解在源码和字节码上保留 RUNTIME:注解在所有的阶段都保留 示例:123456@Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME, ) //当前注解只保留在源码时期public @interface MyAn4 &#123; String name(); int age();&#125; 3.5 解析注解反射机制 method.isAnnotationPresent(注解.class):判断方法上是否有指定的注解 method.getAnnotation(注解.class);获取方法上指定的注解 案例2-自定@MyTest注解,实现单元测试的功能123456789需求分析: 定义一个类,在类中提供多个方法,在部分方法上添加自定义的 @MyTest 注解,让带有@MyTest的注解方法执行.技术分析: 自定义注解 @MyTest步骤分析: 1.定义@MyTest注解,声明该注解只能使用在方法上,生成注解的存活时期为运行时期 2.定义一个类,在类中提供多个方法,在部分方法上添加MyTest注解 3.让带有@MyTest的方法执行 示例@MyTest注解:1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyTest &#123;&#125; 示例AnnotationDemo类:123456789101112131415161718public class AnnotationDemo &#123; @MyTest public void test01() &#123; System.out.println(&quot;如今的现在早已不是曾经说好的以后...&quot;); &#125; @MyTest private void test02() &#123; System.out.println(&quot;我希望你们下去把反射练3遍&quot;); &#125; @MyTest public void test03() &#123; System.out.println(&quot;我的爱好:迪丽热巴&quot;); &#125;&#125; 示例AnnotationMain类:123456789101112131415161718192021222324252627282930/** * @program: Reflection-&gt;AnnotationMain * @description: 自定义注解启动 * 目的:模拟@Test 让有@MyTest注解的方法实现测试功能 * 1.创建注解@MyTest * 2.使用元注解规范@MyTest出现的位置 * 3.使用元注解让@MyTest保留到运行时期 * 4.使用注解解析 让有@MyTest注解的方法运行 * @author: 兵哥 * @create: 2020-01-10 02:04 **/public class AnnotationMain &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; //通过反射获取到目标类的字节码文件 Class clazz = Class.forName(&quot;cn.kgc.c_annotation.AnnotationDemo&quot;); AnnotationDemo annotationDemo = (AnnotationDemo) clazz.newInstance(); //获取所有自己的方法 Method[] Methods = clazz.getMethods(); for (Method method : Methods) &#123; //判断每个方法上是否有注解 boolean b = method.isAnnotationPresent(MyTest.class); if (b) &#123; //让方法执行 //1.调用该方法的对象 //2.方法运行过程中需要的参数 method.invoke(annotationDemo); &#125; &#125; &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}